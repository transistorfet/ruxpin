
* there is currently no checking for illegal characters in each path component
* you were also going to implement rename(), and getcwd()
* implement link

* when a segment is copied, it only copies the pages loaded into memory at that time, and puts 0 for all other pages, but that means when
  those pages are loaded, they will be duplicated.  The solution is to have a cache for each file/exec that is being used which holds a
  reference to each page, and once it is dropped, those pages will be freed, and when a page is loaded, the cache is searched first.  I'm
  not yet sure how I'd like to implement this, and I still haven't exactly figured out how other OSes do it
* fix the sbrk growing/shrinking
* need to change how segments are shared, and how pages are shared (need a page cache)


* think about multicore and what that would mean for everything

* fix the blocking/unblocking code (including exits) to use multiple queues and an event system of some sorts to improve the performance of checks
* make methods on File for fs operations (including unlink/rename?), so you don't have to always use vfs::read(file)

* should binaries move to api to better reflect that it's integrating code that uses multiple subsystems, rather than being an isolated subsystem
  Or should you even move it to its own crate, so that it can be selectively compiled in? but it would still need to be used by the api... can the
  api (as an integrating layer) be separate from the kernel crate?

* modify the proc macro for encoding system calls to be a bit cleaner (not have to put the {} at the end, fit it all in one line, etc)


WHAT IFS:

* how could I make it more event-oriented rather than traditional unixy

* what if you added json for procfs's data, to make it easier to parse?  What if you made json and/or unixstd file formats a compile
  time feature flag?  What if procfs (and all the others) where their own crates with their own feature flags, that are tied together
  by a toplevel config crate (ie. the breakup into crates)

* how would you isolate the unix-specific aspects of the api such that you could implement a light unix-to-ruxpin
  shim on the user process side (or even on the kernel side), so that the ruxpin-native api is not constrained by
  unix but is compatible enough to be source compatible.  Things like waitpid, which take a pointer to the location to put the status,
  it would be nice to have a safer means of passing back data
* can you separate the syscalls, maybe even based on permission levels as well as function, and require permission for each api to
  be granted explicitly, so that APIs security-wise are opt-in, kind of like a web api, or like WASI
* I'm leaning a lot more to the idea of splitting up the APIs into different groups with a different svc number for
  each.  The aarch64 stuff can have the svc-to-api decoding because it might need to be platform specific



HIGH PRIORITY ISSUES:

* should you move to per-page reference counting like linux instead of trying to get away with a single bit

* need to fix the data segment/heap/sbrk stuff because it doesn't change the stack size, and there is no checking or
  support for stack resizing or allocating new stacks in the address space, which is needed for multithread stacks
* can you replace the process vec with a hashmap?  The issue is iterating over the list for procfs readdir support

* think about threads.  I think linux makes every system thread a process with optional sharing of memory and file descriptors, but I
  had been thinking of making thredas separate, making them scheduled, and since there could be a current thread and a current process
  tracked separately by their respective managers (first thing in queue), then a page fault wouldn't have to look up the context, and
  a system call that accessed files would have to fetch both (but not find one via the others)

* need to sort out the tty devices. how irqs can access the device object. whether only the tty subsystem or the driver as well, has
  a reference to the devices as well. how the config will create the device object, and where it stores it (or does it assume each
  driver will register and save global references to the devices if needed?  Is there a better way than using so many global references?


TODO:

* add threading support in api
* add an events system for processes to wait on (IO blocking, process exit, select/poll, etc)

* add a stack guard page to each stack segment, with permissions/mapping in the translation table such that it will cause a fault
  instead of crashing into the adjacent segment.  Linux has this adjustable in size I think

* add more data to procfs
* add . and .. to procfs, as well as devfs and tmpfs
* add mounts to procfs (and make mount command)
* add arrow key support to canonical input
* need to handle the case of accessing ".." on a mounted vnode.  It must correctly fetch the parent node

* add commands: cp, echo, mkdir, mv, ps, pwd, rm, mount, umount


* there's an issue with serial input on the hardware, where it wont show up until a certain number of keys are pressed, but it's a bit
  unpredictable.  I think it might be an issue with when the interrupt occurs based on the buffer fullness??  Could be totally wrong


LOWER PRIORITY ISSUES:

* syscall macros need to be more automatic, the entire marshal/unmarshal should be based only on types.  The macros need a lot of
  work to improve, possibly even using proc macros (eg. an attribute on a syscall function that automagically generates the decoding
  and calling for that function

* sort out issues of copying to/from user space
* there is no userspace/kernelspace copying in the api, which could cause a fatal error if the user program doesn't give a valid
  input, so at some point this needs to be added
* does the linux copy user/kernel function do manual page lookups, including triggering page loading?  Or does it do soemthing else?

* if you put separate locks on the fields of proc, or sub-arc<locks> on at least files and space, so that either can be manipulated
  independently (so a syscall that locks the proc to write a file can still handle a page fault that tries to lock the same proc to
  load the next page

* there is an issue with the emmc driver such that when the image used with qemu is below 2GB or less, the Read command gives a byte
  offset, but when it's 4GB or larger, it gives a sector offset (byte offset / 512).  I'm not sure if this happens with the pi as well
  since I only have an 8GB card.  If there was a way to detect the card size, this could be solved

* could you add feature flags to disable the file subsystem, so you don't need a filesystem at all??



FILESYSTEM TODO:

* add block truncation
* allow for removing directory entries
* add file renaming


* I've tested:
    - superblock alloc_block/free_block
    - superblock alloc_inode/free_inode
    - directory reading
    - directory adding file

* yet to test:
    - superblock/block group writing
    - superblock and group free count being updated correctly
    - everything to do with blocks.rs/zones

* there's a lot of inconsistency between Ext2BlockNumber and BlockNum in ext2 which should be resolved somehow


LOW PRIORITY TODO:

* it turns out there's a from_le and from_be function for u32 and others, so maybe you can simplify the byteorder stuff using them
* can you use a weak reference of some kind for the mount link, instead of NonNull?

* add a proper timer driver (ie. fix the hackish ARM timer driver)
* add functions to delay by a set number of microseconds (might need to use the internal counter), for use by drivers

* get the app linker script working better (can you align to 4KB instead of 64KB)
* can you make an improvement on DeviceRegisters, or should you just use tock-registers

